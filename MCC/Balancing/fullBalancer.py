from multiprocessing.sharedctypes import Value
from .modelBalancer import ModelBalancer
from ..util import formula_to_dict, get_integer_coefficients, same_formula, get_sbml_metabolites, get_fbc_plugin, dict_to_formula
import logging
import re
import z3
import numpy as np


remove_H = re.compile(r"H\d*([^gfe]|$)") # remember to not also remove H from Hg

class FullBalancer(ModelBalancer):
    """
    Class to fully (i.e. mass and charge) balance a model. Cannot handle unbalancable models (see satCore).

    Args:
        model (cobrapy.Model): Model which we intend to balance.
        data_collector: Object which provides a get_assignments function.
        fixed_assignments ({metabolite_id: (formula, charge)}): Optional, Dictionary mapping metabolite ids
            to their respective fixed formula and charge. Will overwrite any information from the data_collector.
        target_model (cobrapy.Model): Model which will be used as a target. The algorithm will try to assign as many 
            charges and formulae as in the target as possible, as long as it does not become less balanced and the charges
            and formulae were also given from the data_collector, unconstrained or in fixed_assignments.
    """ 
    def __init__(self, model, data_collector = None, fixed_assignments = None, target_model = None, **kw):
        self.unknown_metabolites = set()
        self.answer_literals = {}
        self.impartial_information = set() # TODO: still used?
        if target_model is None:
            self.target_model = model.clone()
        else:
            self.target_model = target_model
        super().__init__(model, data_collector, fixed_assignments,  **kw)

    def balance(self):
        """
        Function to run the balancing of the model, specifically passes the answer literals, 
        generated by generate_assertions, to the balance function of the parent class.
        """
        used_literal_ids = set(self.answer_literals.keys()).difference(self.unbalancable_reactions)
        return super().balance([self.answer_literals[id] for id in used_literal_ids])

    def generate_assertions(self):
        """
        Generates assertions for the solver, representing all information of the metabolites and all reactions in the model.
        Reactions are encoded as answer_literals, so that we can identify which reactions cause unbalancibility.
        """
        self.relevant_elements = self._get_relevant_Elements()
        self._generate_metabolite_assertions()
        self._generate_reaction_assertions()

    def _get_assignments(self):
        """
        Gathers the assignments for all metabolites. 
        In a second step then chooses a representative for every proton/charge equivalent assignments.
        """
        self.assignments = super()._get_assignments()
        return self._calculate_cH_equivalents()

    
    def _generate_metabolite_assertions(self):
        """
        Generates the metabolite assertions for every metabolite in the model.
        """
        self.metabolite_symbols = {}
        self.charge_symbols = {}
        for metabolite in self.model.getListOfSpecies():
            self.goal.add(self._generate_metabolite_assertion(metabolite))

    def _generate_metabolite_assertion(self, metabolite):
        """
        Generates the metabolite assertion for the given metabolite. 
        The assertion encodes that the metabolite has to adhere to any of the found assignments.

        Args:
            metabolite (cobrapy.Metabolite): metabolite for which to generate the assertion.
        """
        element_symbols = {}
        constraints = []
        self.charge_symbols[metabolite.id[2:]] = z3.Int(f"charge_{metabolite.id[2:]}")
        for element in self.relevant_elements:
            element_symbols[element] = z3.Int(f"{element}_{metabolite.id[2:]}")
        self.metabolite_symbols[metabolite.id[2:]] = element_symbols
        for assignment in self.assignments[metabolite.id[2:]]:
            dict_formula = formula_to_dict(assignment[0])
            if (not assignment[1] is None):
                charge_constraint = self.charge_symbols[metabolite.id[2:]] == assignment[1]
            else:
                charge_constraint = True
            if "R" in dict_formula:
                constraints.append(z3.And(*[element_symbols[element] >= dict_formula.get(element, 0) for element in self.relevant_elements], charge_constraint))
                self.unknown_metabolites.add(metabolite.id[2:])
            else:
                constraints.append(z3.And(*[element_symbols[element] == dict_formula.get(element, 0) for element in self.relevant_elements], charge_constraint))

        if len(constraints) > 0:
            return z3.Or(constraints)
        else:
            self.unknown_metabolites.add(metabolite.id[2:])
            logging.debug(f"No assignments for {metabolite.id[2:]} found.")
            return z3.And(*[element_symbols[element] >= 0 for element in self.relevant_elements])

    def _generate_reaction_assertions(self):
        # TODO: improve integer coefficient finding
        """
        Generate the assertions for all reactions. Tries to find integer coefficents by repeatedly 
        multiplying with the reciprocal of any non-integer coefficent.
        Reaction assertions encode that every reaction must be balanced w.r.t. mass and charge, 
        disregarding proton differences (i.e. balanced <=> dH == dCharge).
        """
        for reaction in self.model.getListOfReactions():
            if reaction.id in self.unbalancable_reactions: continue
            element_balances = {element : 0 for element in self.relevant_elements}
            factor = get_integer_coefficients(reaction)
            if not (factor is None):
                hydrogen_balance = 0
                charge_balance = 0
                for metabolite_id, coeff in get_sbml_metabolites(reaction).items():
                    coeff *= factor
                    for element in self.relevant_elements:
                        if element == "H": continue
                        element_balances[element] = element_balances[element] + (int(coeff) * self.metabolite_symbols[metabolite_id][element])
                    hydrogen_balance = hydrogen_balance + (int(coeff) * self.metabolite_symbols[metabolite_id]["H"])
                    charge_balance = charge_balance + (int(coeff) * self.charge_symbols[metabolite_id])
                answer_literal = z3.Bool(reaction.id)
                self.answer_literals[reaction.id] = answer_literal
                implication = z3.Implies(answer_literal, z3.And(*[element_balances[element] == 0 for element in self.relevant_elements], (hydrogen_balance) == (charge_balance)))
                self.goal.add(implication)

    def assign_from_solver(self, model = None):
        """
        Translate balancing assignments from the z3 variables to the given model.

        Args:
            model (cobrapy.Model): Optional; Model to which we want to assign the assignments. Defaults to self.model.
        
        """
        m = self.solver.model() if model is None else model
        set_values = set()
        for metabolite in self.model.getListOfSpecies():
            element_dict = {}
            plugin = get_fbc_plugin(metabolite)
            metabolite_elements = plugin.chemical_formula
            metabolite_elements = formula_to_dict(metabolite_elements)
            for element in self.relevant_elements:
                if (not (((assigned_value := m[self.metabolite_symbols[metabolite.id[2:]][element]]) is None)) and (assigned_value.as_long() != 0)) or (element in metabolite_elements):
                    element_dict[element] = assigned_value.as_long()
                    set_values.add(metabolite.id[2:])
            if type((p := plugin.setChemicalFormula(dict_to_formula(element_dict)))) == int and p < 0:
                logging.error(f"Setting chemical formula for {metabolite.id} to {dict_to_formula(element_dict)} failed with code {p}")
                raise ValueError
            charge = m[self.charge_symbols[metabolite.id[2:]]]
            if charge == None:
                if type(p := plugin.setCharge(0)) == int and p < 0:
                    logging.error(f"Setting chemical formula for {metabolite.id} to {0} failed with code {p}")
                    raise ValueError
                
                # since note appending does not work / documentation is unclear, we use a workaround
                old_str = metabolite.notes_string[10:-17]
                metabolite.setNotes(old_str + f'''<p>charge inferrence: unknown charge</p>\n</html>''')
            else:
                if type(p := plugin.setCharge(charge.as_long())) == int and p < 0:
                    logging.error(f"Setting chemical formula for {metabolite.id} to {charge.as_long()} failed with code {p}")
                    raise ValueError
            target_plugin = get_fbc_plugin(self.target_model.getSpecies(metabolite.id))
            if (metabolite.id[2:] in self.unknown_metabolites) and (element_dict.get('H', 0) == 0 and plugin.charge < 0 and target_plugin.charge != metabolite.charge) or plugin.charge < -8: 
                logging.debug(f"adjusting hydrogen count for {metabolite.id[2:]}, from {metabolite_elements.get('H', 0)} to {-plugin.charge}")
                if element_dict.get('H', 0) == 0: # adjust hydrogen counts and charges for unknown formulae
                    element_dict['H'] = -plugin.charge
                    if type((p := plugin.setChemicalFormula(dict_to_formula(element_dict)))) == int and p < 0:
                        logging.error(f"Setting chemical formula for {metabolite.id} to {dict_to_formula(element_dict)} failed with code {p}")
                        raise ValueError
                    if type(p := plugin.setCharge(0)) == int and p < 0:
                        logging.error(f"Setting chemical formula for {metabolite.id} to {0} failed with code {p}")
                        raise ValueError



    def _get_relevant_Elements(self):
        """
        Gathers all Elements which appear in self.model. Required to generate the corresponding z3 variables.
        """
        relevant_elements = set()
        for metabolite in self.model.getListOfSpecies():
            for assignment in self.assignments[metabolite.id[2:]]:
                dict_formula = formula_to_dict(assignment[0])
                for key in dict_formula:
                    if key == "R": continue
                    relevant_elements.add(key)
            metabolite_elements = formula_to_dict(get_fbc_plugin(metabolite).chemical_formula)
            for key in metabolite_elements:
                if key in ["R", "X", "*", "."]: continue
                relevant_elements.add(key)
        return relevant_elements


    def _calculate_cH_equivalents(self, reduce = True):
        """
        Calculates which assignments for each metabolite represent assignments which only differ in their protonation.

        Args:
            reduce (bool): Optinal; If True, a representative is chosen, based on the target model and the least charge.
                Defaults to True.
        
        Returns:
            If reduce: Dictionary mapping metabolite ids to lists of assignments which all differ in more than their protonation
                =>{metabolite_id: set((formula, charge))}

            Otherwise: Dictionary mapping metabolite ids to dictionaries which then map the different non-hydrogen formulae to dictionaries,
                mapping different hydrogen/charge differences to sets of assignments which only differ in their protonation.
                =>{metabolite_id: {nonH_formula  :{(hydrogen - charge) : set((formula, charge))}}}
        """
        # TODO: The strucuted assignment could be simplified a bit => map from (nonH_formula, (hydrogen - charge)) 

        ch_independant_assignments = {}
        # calculate cH difference, check rest formulae
        # nonH formula -> ch difference -> full formula
        for metabolite in self.model.getListOfSpecies():
            if metabolite.id[2:] in self.fixed_assignments:
                if(reduce):
                    ch_independant_assignments[metabolite.id[2:]] = [self.fixed_assignments[metabolite.id[2:]]]
                else:
                    assignment = self.fixed_assignments[metabolite.id[2:]]
                    nonH_formula = remove_H.sub(r"\1", assignment[0])
                    assignment_dict = formula_to_dict(assignment[0])
                    if not assignment[1] is None:
                        diff = assignment_dict.get("H", 0) - assignment[1]
                    else:
                        diff = None
                    ch_independant_assignments[metabolite.id[2:]] = {diff : {nonH_formula : self.fixed_assignments[metabolite.id[2:]]}}
                continue
            all_assignments = self.data_collector.get_assignments(metabolite, database_seperated=True)
            none_assignments = set()
            structured_assignments = {}
            for assignment in all_assignments:
                if assignment[1] is None:
                    none_assignments.add(assignment)
                    continue
                nonH_formula = remove_H.sub(r"\1", assignment[0])
                assignment_dict = formula_to_dict(assignment[0])
                h_count = assignment_dict.get("H", 0)
                formulae = structured_assignments.get(nonH_formula, {})
                same_dict = formulae.get((h_count - assignment[1]), set())
                same_dict.add(assignment)
                formulae[(h_count - assignment[1])] = same_dict
                structured_assignments[nonH_formula] = formulae
            if reduce: 
                reduced_formulae = set()
                for nonH_formula in structured_assignments:
                    for diff, assignments in structured_assignments[nonH_formula].items():
                        best = None
                        for assignment in assignments:
                            original_plugin = get_fbc_plugin(self.target_model.getSpecies(metabolite.id))
                            if same_formula(assignment[0], original_plugin.chemical_formula) and assignment[1] == original_plugin.charge:
                                best = assignment
                                break
                        if best is None:
                            # if we cant adhere to the model, we want 1. to take the formula with largest database support
                            max_support = max([len(all_assignments[assignment]) for assignment in assignments])
                            best = [assignment for assignment in assignments if len(all_assignments[assignment]) == max_support]
                            # and 2. the most neutral representation
                            best = min([(np.absolute(assignment[1]), assignment) for assignment in best])[1]

                        reduced_formulae.add(best)
                if len(reduced_formulae) == 0:
                    ch_independant_assignments[metabolite.id[2:]] = none_assignments
                else:
                    ch_independant_assignments[metabolite.id[2:]] = reduced_formulae.union(none_assignments)
            else:
                ch_independant_assignments[metabolite.id[2:]] = structured_assignments
        return ch_independant_assignments