from ..core import Formula

from ..Balancing.balancer import Balancer
from ..ModelInterface.ModelInterface import ModelInterface
from ..util import get_integer_coefficients 
import logging
import re
import z3
import numpy as np


remove_H = re.compile(r"H\d*([^gfe]|$)") # remember to not also remove H from Hg

class FullBalancer(Balancer):
    """
    Class to fully (i.e. mass and charge) balance a model. Cannot handle unbalancable models (see satCore).

    Args:
        model (cobrapy.Model): Model which we intend to balance.
        data_collector: Object which provides a get_assignments function.
        fixed_assignments ({metabolite_id: (formula, charge)}): Optional, Dictionary mapping metabolite ids
            to their respective fixed formula and charge. Will overwrite any information from the data_collector.
        target_model (cobrapy.Model): Model which will be used as a target. The algorithm will try to assign as many 
            charges and formulae as in the target as possible, as long as it does not become less balanced and the charges
            and formulae were also given from the data_collector, unconstrained or in fixed_assignments.
    """ 
    def __init__(self, model_interface : ModelInterface, data_collector = None, fixed_assignments = None, target_model_interface : ModelInterface = None, **kw):
        self.unknown_metabolite_ids = set()
        self.answer_literals = {}
        self.impartial_information = set() # TODO: still used?
        if target_model_interface is None:
            self.target_model_interface = model_interface.copy()
        else:
            self.target_model_interface = target_model_interface
        self.model_interface = model_interface
        self.data_collector = data_collector
        self.fixed_assignments = {} if fixed_assignments is None else {meta_id : (Formula(formula), charge) for meta_id, (formula, charge) in fixed_assignments.items()}
        self.reaction_reasons = {}
        self.incomplete_formulae = set()
        self.unbalancable_reactions = self.model_interface.get_pseudo_reactions()
        self.assignments = self._get_assignments()
        super().__init__()
    

    def balance(self):
        """
        Function to run the balancing of the model, specifically passes the answer literals, 
        generated by generate_assertions, to the balance function of the parent class.
        """
        used_literal_ids = set(self.answer_literals.keys()).difference(self.unbalancable_reactions)
        return super().balance([self.answer_literals[id] for id in used_literal_ids])

    def generate_assertions(self):
        """
        Generates assertions for the solver, representing all information of the metabolites and all reactions in the model.
        Reactions are encoded as answer_literals, so that we can identify which reactions cause unbalancibility.
        """
        self.relevant_elements = self._get_relevant_Elements()
        self._generate_metabolite_assertions()
        self._generate_reaction_assertions()

    def _get_assignments(self):
        """
        Gets assignment for all metabolites of the models from the given data_collector.
        Checks for incomplete formulae (i.e. formulae containing an R.)

        Returns:
            Dictionary mapping metabolite ids to their found assignments.
        """
        all_assignments = self.fixed_assignments.copy()
        for metabolite in self.model_interface.metabolites.values():
            if metabolite.id in self.fixed_assignments:
                continue
            elif not (assignments := self.data_collector.get_assignments(metabolite)) is None:
                if any(("R" in assignment[0]) for assignment in assignments):
                    self.incomplete_formulae.add(metabolite.id)
                all_assignments[metabolite.id] = assignments
            else:
                logging.error(f"No information for {metabolite.id} in DataCollector! You might want to gather information first or set a fixed assignment.")
                raise RuntimeError
        return self._calculate_cH_equivalents()
        
    
    def _generate_metabolite_assertions(self):
        """
        Generates the metabolite assertions for every metabolite in the model.
        """
        self.metabolite_symbols = {}
        self.charge_symbols = {}
        for metabolite in self.model_interface.metabolites.values():
            self.goal.add(self._generate_metabolite_assertion(metabolite))

    def _generate_metabolite_assertion(self, metabolite):
        """
        Generates the metabolite assertion for the given metabolite. 
        The assertion encodes that the metabolite has to adhere to any of the found assignments.

        Args:
            metabolite (cobrapy.Metabolite): metabolite for which to generate the assertion.
        """
        element_symbols = {}
        constraints = []
        self.charge_symbols[metabolite.id] = z3.Int(f"charge_{metabolite.id}")
        for element in self.relevant_elements:
            element_symbols[element] = z3.Int(f"{element}_{metabolite.id}")
        self.metabolite_symbols[metabolite.id] = element_symbols
        for formula, charge in self.assignments[metabolite.id]:
            if (not charge is None):
                charge_constraint = self.charge_symbols[metabolite.id] == charge
            else:
                charge_constraint = True
            if formula["R"] > 0:
                constraints.append(z3.And(*[element_symbols[element] >= formula[element] for element in self.relevant_elements], charge_constraint))
                self.unknown_metabolite_ids.add(metabolite.id)
            else:
                constraints.append(z3.And(*[element_symbols[element] == formula[element] for element in self.relevant_elements], charge_constraint))

        if len(constraints) > 0:
            return z3.Or(constraints)
        else:
            self.unknown_metabolite_ids.add(metabolite.id)
            logging.debug(f"No assignments for {metabolite.id} found.")
            return z3.And(*[element_symbols[element] >= 0 for element in self.relevant_elements])

    def _generate_reaction_assertions(self):
        # TODO: improve integer coefficient finding
        """
        Generate the assertions for all reactions. Tries to find integer coefficents by repeatedly 
        multiplying with the reciprocal of any non-integer coefficent.
        Reaction assertions encode that every reaction must be balanced w.r.t. mass and charge, 
        disregarding proton differences (i.e. balanced <=> dH == dCharge).
        """
        for reaction in self.model_interface.reactions.values():
            if reaction in self.unbalancable_reactions: continue
            element_balances = {element : 0 for element in self.relevant_elements}
            factor = get_integer_coefficients(reaction)
            if not (factor is None):
                hydrogen_balance = 0
                charge_balance = 0
                for metabolite, coeff in reaction.metabolites.items():
                    coeff *= factor
                    for element in self.relevant_elements:
                        if element == "H": continue
                        element_balances[element] = element_balances[element] + (int(coeff) * self.metabolite_symbols[metabolite.id][element])
                    hydrogen_balance = hydrogen_balance + (int(coeff) * self.metabolite_symbols[metabolite.id]["H"])
                    charge_balance = charge_balance + (int(coeff) * self.charge_symbols[metabolite.id])
                answer_literal = z3.Bool(reaction.id)
                self.answer_literals[reaction.id] = answer_literal
                implication = z3.Implies(answer_literal, z3.And(*[element_balances[element] == 0 for element in self.relevant_elements], (hydrogen_balance) == (charge_balance)))
                self.goal.add(implication)

    def assign_from_solver(self, model = None):
        """
        Translate balancing assignments from the z3 variables to the given model.

        Args:
            model (cobrapy.Model): Optional; Model from which we want to assign the assignments. Defaults to self.solver.model.
        
        """
        m = self.solver.model() if model is None else model
        for metabolite in self.model_interface.metabolites.values():
            for element in self.relevant_elements:
                if (not (((assigned_value := m[self.metabolite_symbols[metabolite.id][element]]) is None)) and (assigned_value.as_long() != 0)) or (element in metabolite.formula):
                    metabolite.formula[element] = assigned_value.as_long()
            charge = m[self.charge_symbols[metabolite.id]]
            if charge == None:
                metabolite.charge = 0
                logging.warning(f"Could not find charge for metabolite {metabolite.id}. Setting it to 0.")
                metabolite.notes["charge inferrence"] = "unknown charge"
            else:
                metabolite.charge = charge.as_long()
            target_metabolite = self.target_model_interface.metabolites[metabolite.id]
            if (metabolite.id in self.unknown_metabolite_ids) and (metabolite.formula["H"] == 0 and metabolite.charge < 0 and target_metabolite.charge != metabolite.charge) or metabolite.charge < -8: 
                logging.debug(f"adjusting hydrogen count for {metabolite.id}, from {metabolite.formula['H']} to {-metabolite.charge}")
                metabolite.formula['H'] = -metabolite.charge


    def _get_relevant_Elements(self):
        """
        Gathers all Elements which appear in self.model. Required to generate the corresponding z3 variables.
        """
        relevant_elements = set()
        for metabolite in self.model_interface.metabolites.values():
            for assignment in self.assignments[metabolite.id]:
                for key in assignment[0]:
                    if key == "R": continue
                    relevant_elements.add(key)
            for key in metabolite.formula:
                if key in ["R", "X", "*", "."]: continue
                relevant_elements.add(key)
        return relevant_elements


    def _calculate_cH_equivalents(self, reduce = True):
        """
        Calculates which assignments for each metabolite represent assignments which only differ in their protonation.

        Args:
            reduce (bool): Optinal; If True, a representative is chosen, based on the target model and the least charge.
                Defaults to True.
        
        Returns:
            If reduce: Dictionary mapping metabolite ids to lists of assignments which all differ in more than their protonation
                =>{metabolite_id: set((formula, charge))}

            Otherwise: Dictionary mapping metabolite ids to dictionaries which then map the different non-hydrogen formulae to dictionaries,
                mapping different hydrogen/charge differences to sets of assignments which only differ in their protonation.
                =>{metabolite_id: {nonH_formula  :{(hydrogen - charge) : set((formula, charge))}}}
        """
        # TODO: The strucuted assignment could be simplified a bit => map from (nonH_formula, (hydrogen - charge)) 

        ch_independant_assignments = {}
        # calculate cH difference, check rest formulae
        # nonH formula -> ch difference -> full formula
        for metabolite in self.model_interface.metabolites.values():
            original_metabolite = self.target_model_interface.metabolites[metabolite.id]
            if metabolite.id in self.fixed_assignments:
                if(reduce):
                    ch_independant_assignments[metabolite.id] = [self.fixed_assignments[metabolite.id]]
                else:
                    formula, charge = self.fixed_assignments[metabolite.id]
                    nonH_formula = formula.copy()
                    nonH_formula["H"] = 0
                    if not charge is None:
                        diff = formula["H"] - charge
                    else:
                        diff = None
                    ch_independant_assignments[metabolite.id] = {diff : {nonH_formula : (formula, charge)}}
                continue
            all_assignments = self.data_collector.get_assignments(metabolite, database_seperated=True)
            none_assignments = set()
            structured_assignments = {}
            for formula, charge in all_assignments:
                if charge is None:
                    none_assignments.add((formula, charge))
                    continue
                nonH_formula = formula.copy()
                nonH_formula["H"] = 0
                formulae = structured_assignments.get(nonH_formula, {})
                same_dict = formulae.get((formula["H"] - charge), set())
                same_dict.add((formula, charge))
                formulae[(formula["H"] - charge)] = same_dict
                structured_assignments[nonH_formula] = formulae
            if reduce: 
                reduced_formulae = set()
                for nonH_formula in structured_assignments:
                    for diff, assignments in structured_assignments[nonH_formula].items():
                        best = None
                        for formula, charge in assignments:
                            if formula == original_metabolite.formula and charge == original_metabolite.charge:
                                best = (formula, charge)
                                break
                        if best is None:
                            # if we cant adhere to the model, we want 1. to take the formula with largest database support
                            max_support = max([len(all_assignments[assignment]) for assignment in assignments])
                            best = [assignment for assignment in assignments if len(all_assignments[assignment]) == max_support]
                            # and 2. the most neutral representation
                            best = min([(np.absolute(assignment[1]), assignment) for assignment in best])[1]

                        reduced_formulae.add(best)
                if len(reduced_formulae) == 0:
                    ch_independant_assignments[metabolite.id] = none_assignments
                else:
                    ch_independant_assignments[metabolite.id] = reduced_formulae.union(none_assignments)
            else:
                ch_independant_assignments[metabolite.id] = structured_assignments
        return ch_independant_assignments